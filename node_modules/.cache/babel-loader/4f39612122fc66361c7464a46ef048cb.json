{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/jeong-go-eun/Desktop/metagate/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar cbor = require('borc');\n\nvar multihashing = require('multihashing-async');\n\nvar CID = require('cids');\n\nvar waterfall = require('async/waterfall');\n\nvar setImmediate = require('async/setImmediate');\n\nvar isCircular = require('is-circular');\n\nvar resolver = require('./resolver'); // https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\n\n\nvar CID_CBOR_TAG = 42;\n\nfunction tagCID(cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).buffer;\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([Buffer.from('00', 'hex'), // thanks jdag\n  cid]));\n}\n\nvar decoder = new cbor.Decoder({\n  tags: _defineProperty({}, CID_CBOR_TAG, function (val) {\n    // remove that 0\n    val = val.slice(1);\n    return {\n      '/': val\n    };\n  })\n});\n\nfunction replaceCIDbyTAG(dagNode) {\n  var circular;\n\n  try {\n    circular = isCircular(dagNode);\n  } catch (e) {\n    circular = false;\n  }\n\n  if (circular) {\n    throw new Error('The object passed has circular references');\n  }\n\n  function transform(obj) {\n    if (!obj || Buffer.isBuffer(obj) || typeof obj === 'string') {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform);\n    }\n\n    var keys = Object.keys(obj); // only `{'/': 'link'}` are valid\n\n    if (keys.length === 1 && keys[0] === '/') {\n      // Multiaddr encoding\n      // if (typeof link === 'string' && isMultiaddr(link)) {\n      //  link = new Multiaddr(link).buffer\n      // }\n      return tagCID(obj['/']);\n    } else if (keys.length > 0) {\n      // Recursive transform\n      var out = {};\n      keys.forEach(function (key) {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key]);\n        } else {\n          out[key] = obj[key];\n        }\n      });\n      return out;\n    } else {\n      return obj;\n    }\n  }\n\n  return transform(dagNode);\n}\n\nexports = module.exports;\n\nexports.serialize = function (dagNode, callback) {\n  var serialized;\n\n  try {\n    var dagNodeTagged = replaceCIDbyTAG(dagNode);\n    serialized = cbor.encode(dagNodeTagged);\n  } catch (err) {\n    return setImmediate(function () {\n      return callback(err);\n    });\n  }\n\n  setImmediate(function () {\n    return callback(null, serialized);\n  });\n};\n\nexports.deserialize = function (data, callback) {\n  var deserialized;\n\n  try {\n    deserialized = decoder.decodeFirst(data);\n  } catch (err) {\n    return setImmediate(function () {\n      return callback(err);\n    });\n  }\n\n  setImmediate(function () {\n    return callback(null, deserialized);\n  });\n};\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version=1] - CID version number\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\n\n\nexports.cid = function (dagNode, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  var hashAlg = options.hashAlg || resolver.defaultHashAlg;\n  var version = typeof options.version === 'undefined' ? 1 : options.version;\n  waterfall([function (cb) {\n    return exports.serialize(dagNode, cb);\n  }, function (serialized, cb) {\n    return multihashing(serialized, hashAlg, cb);\n  }, function (mh, cb) {\n    return cb(null, new CID(version, resolver.multicodec, mh));\n  }], callback);\n};","map":null,"metadata":{},"sourceType":"script"}